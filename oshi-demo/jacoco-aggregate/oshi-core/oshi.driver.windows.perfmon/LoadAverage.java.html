<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>LoadAverage.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">oshi-demo</a> &gt; <a href="../index.html" class="el_bundle">oshi-core</a> &gt; <a href="index.source.html" class="el_package">oshi.driver.windows.perfmon</a> &gt; <span class="el_source">LoadAverage.java</span></div><h1>LoadAverage.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2022 The OSHI Project Contributors
 * SPDX-License-Identifier: MIT
 */
package oshi.driver.windows.perfmon;

import java.util.Arrays;
import java.util.List;
import java.util.Map;

import oshi.annotation.concurrent.ThreadSafe;
import oshi.driver.windows.perfmon.ProcessInformation.IdleProcessorTimeProperty;
import oshi.driver.windows.perfmon.SystemInformation.ProcessorQueueLengthProperty;
import oshi.util.tuples.Pair;

/**
 * Utility to calculate a load average equivalent metric on Windows. Starts a daemon thread to collect the necessary
 * counters and averages in 5-second intervals.
 */
@ThreadSafe
public final class LoadAverage {

    // Daemon thread for Load Average
<span class="nc" id="L24">    private static Thread loadAvgThread = null;</span>

<span class="nc" id="L26">    private static double[] loadAverages = new double[] { -1d, -1d, -1d };</span>
<span class="nc" id="L27">    private static final double[] EXP_WEIGHT = new double[] {</span>
            // 1-, 5-, and 15-minute exponential smoothing weight
<span class="nc" id="L29">            Math.exp(-5d / 60d), Math.exp(-5d / 300d), Math.exp(-5d / 900d) };</span>

    private LoadAverage() {
    }

    public static double[] queryLoadAverage(int nelem) {
<span class="nc" id="L35">        synchronized (loadAverages) {</span>
<span class="nc" id="L36">            return Arrays.copyOf(loadAverages, nelem);</span>
        }
    }

    public static synchronized void stopDaemon() {
<span class="nc bnc" id="L41" title="All 2 branches missed.">        if (loadAvgThread != null) {</span>
<span class="nc" id="L42">            loadAvgThread.interrupt();</span>
<span class="nc" id="L43">            loadAvgThread = null;</span>
        }
<span class="nc" id="L45">    }</span>

    public static synchronized void startDaemon() {
<span class="nc bnc" id="L48" title="All 2 branches missed.">        if (loadAvgThread != null) {</span>
<span class="nc" id="L49">            return;</span>
        }
<span class="nc" id="L51">        loadAvgThread = new Thread(&quot;OSHI Load Average daemon&quot;) {</span>
            @Override
            public void run() {
                // Initialize tick counters
<span class="nc" id="L55">                Pair&lt;Long, Long&gt; nonIdlePair = LoadAverage.queryNonIdleTicks();</span>
<span class="nc" id="L56">                long nonIdleTicks0 = nonIdlePair.getA();</span>
<span class="nc" id="L57">                long nonIdleBase0 = nonIdlePair.getB();</span>
                long nonIdleTicks;
                long nonIdleBase;

                // Use nanoTime to synchronize queries at 5 seconds
<span class="nc" id="L62">                long initNanos = System.nanoTime();</span>
                long delay;

                // The two components of load average
                double runningProcesses;
                long queueLength;

                try {
<span class="nc" id="L70">                    Thread.sleep(2500L);</span>
<span class="nc" id="L71">                } catch (InterruptedException e) {</span>
<span class="nc" id="L72">                    Thread.currentThread().interrupt();</span>
<span class="nc" id="L73">                }</span>
<span class="nc bnc" id="L74" title="All 2 branches missed.">                while (!Thread.currentThread().isInterrupted()) {</span>
                    // get non-idle ticks, proxy for average processes running
<span class="nc" id="L76">                    nonIdlePair = LoadAverage.queryNonIdleTicks();</span>
<span class="nc" id="L77">                    nonIdleTicks = nonIdlePair.getA() - nonIdleTicks0;</span>
<span class="nc" id="L78">                    nonIdleBase = nonIdlePair.getB() - nonIdleBase0;</span>
<span class="nc bnc" id="L79" title="All 4 branches missed.">                    if (nonIdleBase &gt; 0 &amp;&amp; nonIdleTicks &gt; 0) {</span>
<span class="nc" id="L80">                        runningProcesses = (double) nonIdleTicks / nonIdleBase;</span>
                    } else {
<span class="nc" id="L82">                        runningProcesses = 0d;</span>
                    }
<span class="nc" id="L84">                    nonIdleTicks0 = nonIdlePair.getA();</span>
<span class="nc" id="L85">                    nonIdleBase0 = nonIdlePair.getB();</span>
                    // get processes waiting
<span class="nc" id="L87">                    queueLength = SystemInformation.queryProcessorQueueLength()</span>
<span class="nc" id="L88">                            .getOrDefault(ProcessorQueueLengthProperty.PROCESSORQUEUELENGTH, 0L);</span>

<span class="nc" id="L90">                    synchronized (loadAverages) {</span>
                        // Init to running procs the first time
<span class="nc bnc" id="L92" title="All 2 branches missed.">                        if (loadAverages[0] &lt; 0d) {</span>
<span class="nc" id="L93">                            Arrays.fill(loadAverages, runningProcesses);</span>
                        }
                        // Use exponential smoothing to update values
<span class="nc bnc" id="L96" title="All 2 branches missed.">                        for (int i = 0; i &lt; loadAverages.length; i++) {</span>
<span class="nc" id="L97">                            loadAverages[i] *= EXP_WEIGHT[i];</span>
<span class="nc" id="L98">                            loadAverages[i] += (runningProcesses + queueLength) * (1d - EXP_WEIGHT[i]);</span>
                        }
<span class="nc" id="L100">                    }</span>

<span class="nc" id="L102">                    delay = 5000L - (System.nanoTime() - initNanos) % 5_000_000_000L / 1_000_000;</span>
<span class="nc bnc" id="L103" title="All 2 branches missed.">                    if (delay &lt; 500L) {</span>
<span class="nc" id="L104">                        delay += 5000L;</span>
                    }
                    try {
<span class="nc" id="L107">                        Thread.sleep(delay);</span>
<span class="nc" id="L108">                    } catch (InterruptedException e) {</span>
<span class="nc" id="L109">                        Thread.currentThread().interrupt();</span>
<span class="nc" id="L110">                    }</span>
                }
<span class="nc" id="L112">            }</span>
        };
<span class="nc" id="L114">        loadAvgThread.setDaemon(true);</span>
<span class="nc" id="L115">        loadAvgThread.start();</span>
<span class="nc" id="L116">    }</span>

    private static Pair&lt;Long, Long&gt; queryNonIdleTicks() {
        Pair&lt;List&lt;String&gt;, Map&lt;IdleProcessorTimeProperty, List&lt;Long&gt;&gt;&gt; idleValues = ProcessInformation
<span class="nc" id="L120">                .queryIdleProcessCounters();</span>
<span class="nc" id="L121">        List&lt;String&gt; instances = idleValues.getA();</span>
<span class="nc" id="L122">        Map&lt;IdleProcessorTimeProperty, List&lt;Long&gt;&gt; valueMap = idleValues.getB();</span>
<span class="nc" id="L123">        List&lt;Long&gt; proctimeTicks = valueMap.get(IdleProcessorTimeProperty.PERCENTPROCESSORTIME);</span>
<span class="nc" id="L124">        List&lt;Long&gt; proctimeBase = valueMap.get(IdleProcessorTimeProperty.ELAPSEDTIME);</span>
<span class="nc" id="L125">        long nonIdleTicks = 0L;</span>
<span class="nc" id="L126">        long nonIdleBase = 0L;</span>
<span class="nc bnc" id="L127" title="All 2 branches missed.">        for (int i = 0; i &lt; instances.size(); i++) {</span>
<span class="nc bnc" id="L128" title="All 2 branches missed.">            if (&quot;_Total&quot;.equals(instances.get(i))) {</span>
<span class="nc" id="L129">                nonIdleTicks += proctimeTicks.get(i);</span>
<span class="nc" id="L130">                nonIdleBase += proctimeBase.get(i);</span>
<span class="nc bnc" id="L131" title="All 2 branches missed.">            } else if (&quot;Idle&quot;.equals(instances.get(i))) {</span>
<span class="nc" id="L132">                nonIdleTicks -= proctimeTicks.get(i);</span>
            }
        }
<span class="nc" id="L135">        return new Pair&lt;&gt;(nonIdleTicks, nonIdleBase);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>