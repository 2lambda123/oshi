<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Kstat2.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">oshi-core</a> &gt; <a href="index.source.html" class="el_package">oshi.jna.platform.unix</a> &gt; <span class="el_source">Kstat2.java</span></div><h1>Kstat2.java</h1><pre class="source lang-java linenums">/*
 * MIT License
 *
 * Copyright (c) 2022 The OSHI Project Contributors: https://github.com/oshi/oshi/graphs/contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the &quot;Software&quot;), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
package oshi.jna.platform.unix;

import com.sun.jna.Library;
import com.sun.jna.Native;
import com.sun.jna.Pointer;
import com.sun.jna.PointerType;
import com.sun.jna.Structure;
import com.sun.jna.Structure.FieldOrder;
import com.sun.jna.Union;
import com.sun.jna.ptr.PointerByReference;

import oshi.jna.platform.unix.Kstat2.Kstat2NV.UNION.IntegersArr;
import oshi.jna.platform.unix.Kstat2.Kstat2NV.UNION.StringsArr;

/**
 * Kstat2 library. The kstat2 facility is a general-purpose mechanism for
 * providing kernel statistics to users.
 * &lt;p&gt;
 * Kstat2 is available in Solaris 11.4 and later.
 */
public interface Kstat2 extends Library {

    /**
     * Requires Solaris 11.4. Users should test for UnsatisfiedLinkError
     */
<span class="nc" id="L49">    Kstat2 INSTANCE = Native.load(&quot;kstat2&quot;, Kstat2.class);</span>

    // enum kstat2_status -- return values and error codes
    int KSTAT2_S_OK = 0; // Request was successful
    int KSTAT2_S_NO_PERM = 1; // Insufficient permissions for request
    int KSTAT2_S_NO_MEM = 2; // Insufficient memory available
    int KSTAT2_S_NO_SPACE = 3; // No space available for operation
    int KSTAT2_S_INVAL_ARG = 4; // Invalid argument supplied
    int KSTAT2_S_INVAL_STATE = 5; // Invalid state for this request
    int KSTAT2_S_INVAL_TYPE = 6; // Invalid data type found
    int KSTAT2_S_NOT_FOUND = 7; // Resource not found
    int KSTAT2_S_CONC_MOD = 8; // Concurrent modification of map detected
    int KSTAT2_S_DEL_MAP = 9; // Referenced map has been deleted
    int KSTAT2_S_SYS_FAIL = 10; // System call has failed, see errno

    // enum kstat2_match_type
    int KSTAT2_M_STRING = 0; // String
    int KSTAT2_M_GLOB = 1; // Glob with ?, *, or [...]
    int KSTAT2_M_RE = 2; // PCRE Regex

    /*
     * Values in Kstat2NV structure
     */
    // enum kstat2_nv_type
    byte KSTAT2_NVVT_MAP = 0; // Nested Name/Value map
    byte KSTAT2_NVVT_INT = 1; // 64-bit unsigned integer
    byte KSTAT2_NVVT_INTS = 2; // Array of 64-bit unsigned integers
    byte KSTAT2_NVVT_STR = 3; // Null-terminated C string
    byte KSTAT2_NVVT_STRS = 4; // Array of null-terminated C strings

    // enum kstat2_nv_kind
    byte KSTAT2_NVK_SYS = 0x01; // System kstat value type
    byte KSTAT2_NVK_USR = 0x02; // User-supplied value type
    byte KSTAT2_NVK_MAP = 0x04; // Sub-map value type
    byte KSTAT2_NVK_ALL = 0x07; // All value types (only for iteration)

    // enum kstat2_nv_flag
    short KSTAT2_NVF_NONE = 0x00; // No flags present
    short KSTAT2_NVF_INVAL = 0x01; // Value is invalid

    /**
     * Opaque kstat handle.
     */
    class Kstat2Handle extends PointerType {
<span class="nc" id="L93">        private PointerByReference ref = new PointerByReference();</span>

        /**
         * Instantiates and opens a new Kstat2Handle with no filtering. All of the
         * system's kstats will be available. Convenience method for {open()} with a
         * null matcher list.
         */
        public Kstat2Handle() {
<span class="nc" id="L101">            this(null);</span>
<span class="nc" id="L102">        }</span>

        /**
         * Instantiates and opens a new Kstat2Handle filtered with the provided matcher.
         * Convenience method for
         * {@link Kstat2#kstat2_open(PointerByReference, Kstat2MatcherList)}.
         *
         * @param matchers
         *            Only kstats that match one or more of the provided matchers will
         *            be available. If a NULL or empty matcher list is provided, all of
         *            the system's kstats will be available. Restricting the number of
         *            kstats available will improve performance and reduce the memory
         *            footprint.
         */
        public Kstat2Handle(Kstat2MatcherList matchers) {
<span class="nc" id="L117">            super();</span>
<span class="nc" id="L118">            int ks = INSTANCE.kstat2_open(ref, matchers);</span>
<span class="nc bnc" id="L119" title="All 2 branches missed.">            if (ks != KSTAT2_S_OK) {</span>
<span class="nc" id="L120">                throw new Kstat2StatusException(ks);</span>
            }
<span class="nc" id="L122">            this.setPointer(ref.getValue());</span>
<span class="nc" id="L123">        }</span>

        /**
         * Convenience method for {@link Kstat2#kstat2_update(Kstat2Handle)} that
         * synchronises the user's view with that of the kernel. The kernel may at any
         * point add or remove kstats, causing the user's view of the available kstats
         * to become out of date.
         *
         * @return Upon successful completion, returns a int value of
         *         {@link Kstat2#KSTAT2_S_OK}. If an error occurs a value other than
         *         KSTAT2_S_OK is returned.
         */
        public int update() {
<span class="nc" id="L136">            return INSTANCE.kstat2_update(this);</span>
        }

        /**
         * Convenience method for
         * {@link Kstat2#kstat2_lookup_map(Kstat2Handle, String, PointerByReference)}
         * that obtains a reference to a kstat2 map given the URI of the map.
         *
         * @param uri
         *            The URI of the map to return.
         * @return A reference to the map.
         */
        public Kstat2Map lookupMap(String uri) {
<span class="nc" id="L149">            PointerByReference pMap = new PointerByReference();</span>
<span class="nc" id="L150">            int ks = INSTANCE.kstat2_lookup_map(this, uri, pMap);</span>
<span class="nc bnc" id="L151" title="All 2 branches missed.">            if (ks != KSTAT2_S_OK) {</span>
<span class="nc" id="L152">                throw new Kstat2StatusException(ks);</span>
            }
<span class="nc" id="L154">            return new Kstat2Map(pMap.getValue());</span>
        }

        /**
         * Convenience method for {@link Kstat2#kstat2_close(PointerByReference)}. After
         * use, the kstat handle should be closed to reclaim the handles and memory that
         * it allocated on open.
         *
         * @return Upon successful completion, returns a int value of
         *         {@link Kstat2#KSTAT2_S_OK}. If an error occurs a value other than
         *         KSTAT2_S_OK is returned.
         */
        public int close() {
<span class="nc" id="L167">            return INSTANCE.kstat2_close(ref);</span>
        }
    }

    /**
     * Opaque kstat match list.
     */
    class Kstat2MatcherList extends PointerType {
<span class="nc" id="L175">        private PointerByReference ref = new PointerByReference();</span>

        /**
         * Instantiates a new Kstat2MatcherList, allocating the necessary resources.
         * Convenience method for
         * {@link Kstat2#kstat2_alloc_matcher_list(PointerByReference)}.
         * &lt;p&gt;
         * It is the caller's responsibility to free this matcher list by calling
         * {@link #free()}.
         */
        public Kstat2MatcherList() {
<span class="nc" id="L186">            super();</span>
<span class="nc" id="L187">            int ks = INSTANCE.kstat2_alloc_matcher_list(ref);</span>
<span class="nc bnc" id="L188" title="All 2 branches missed.">            if (ks != KSTAT2_S_OK) {</span>
<span class="nc" id="L189">                throw new Kstat2StatusException(ks);</span>
            }
<span class="nc" id="L191">            this.setPointer(ref.getValue());</span>
<span class="nc" id="L192">        }</span>

        /**
         * Convenience method for
         * {@link Kstat2#kstat2_add_matcher(int, String, Kstat2MatcherList)} that adds
         * matchers to the provided matcher list. Each call appends the new matcher to
         * the provided matcher list. Matches are on kstat URI, with the following match
         * types supported: {@link Kstat2#KSTAT2_M_STRING} which performs a direct
         * {@code strcmp} with the kstat URI, {@link Kstat2#KSTAT2_M_GLOB} which
         * performs a glob pattern match using {@code gmatch}, and
         * {@link Kstat2#KSTAT2_M_RE} which performs a Perl Compatible Regular
         * Expression (PCRE) match using {@code pcre_exec}.
         *
         * @param type
         *            The type of matcher, from the {@code kstat2_match_type_t}
         *            enumeration.
         * @param match
         *            The string to match.
         * @return Upon successful completion, returns a int value of
         *         {@link Kstat2#KSTAT2_S_OK}. If an error occurs a value other than
         *         KSTAT2_S_OK is returned.
         */
        public int addMatcher(int type, String match) {
<span class="nc" id="L215">            return INSTANCE.kstat2_add_matcher(type, match, this);</span>
        }

        /**
         * Convenience method for
         * {@link Kstat2#kstat2_free_matcher_list(PointerByReference)} that frees the
         * resources associated with the matcher list.
         *
         * @return Upon successful completion, returns a int value of
         *         {@link Kstat2#KSTAT2_S_OK}. If an error occurs a value other than
         *         KSTAT2_S_OK is returned.
         */
        public int free() {
<span class="nc" id="L228">            return INSTANCE.kstat2_free_matcher_list(ref);</span>
        }
    }

    /**
     * Opaque kstat map handle.
     */
    class Kstat2Map extends PointerType {

        public Kstat2Map() {
<span class="nc" id="L238">            super();</span>
<span class="nc" id="L239">        }</span>

        public Kstat2Map(Pointer p) {
<span class="nc" id="L242">            super(p);</span>
<span class="nc" id="L243">        }</span>

        /**
         * Convenience method for
         * {@link Kstat2#kstat2_map_get(Kstat2Map, String, PointerByReference)} that
         * retrieves the name/value (nv) pair identified by the supplied name.
         *
         * @param name
         *            The uri of the data to retrieve.
         * @return The name/value data.
         */
        public Kstat2NV mapGet(String name) {
<span class="nc" id="L255">            PointerByReference pbr = new PointerByReference();</span>
<span class="nc" id="L256">            int ks = INSTANCE.kstat2_map_get(this, name, pbr);</span>
<span class="nc bnc" id="L257" title="All 2 branches missed.">            if (ks != KSTAT2_S_OK) {</span>
<span class="nc" id="L258">                throw new Kstat2StatusException(ks);</span>
            }
<span class="nc" id="L260">            return new Kstat2NV(pbr.getValue());</span>
        }

        /**
         * Convenience method for
         * {@link Kstat2#kstat2_map_get(Kstat2Map, String, PointerByReference)} that
         * retrieves the name/value (nv) pair identified by the supplied name and
         * returns the value as an object.
         *
         * @param name
         *            The name of the data to retrieve.
         * @return If the value is of type {@link Kstat2#KSTAT2_NVVT_MAP}, a
         *         {@link Kstat2Map} is returned.
         *         &lt;p&gt;
         *         If the value is of type {@link Kstat2#KSTAT2_NVVT_INT}, a
         *         {@link long} is returned.
         *         &lt;p&gt;
         *         If the value is of type {@link Kstat2#KSTAT2_NVVT_INTS}, an array of
         *         {@link long} is returned.
         *         &lt;p&gt;
         *         If the value is of type {@link Kstat2#KSTAT2_NVVT_STR}, a
         *         {@link String} is returned.
         *         &lt;p&gt;
         *         If the value is of type {@link Kstat2#KSTAT2_NVVT_STRS}, an array of
         *         {@link String} is returned.
         *         &lt;p&gt;
         *         If no value exists for this property (error or invalid data
         *         {@link Kstat2#KSTAT2_NVF_INVAL}), returns {@code null}.
         */
        public Object getValue(String name) {
            try {
<span class="nc" id="L291">                Kstat2NV nv = mapGet(name);</span>
<span class="nc bnc" id="L292" title="All 2 branches missed.">                if (nv.flags == KSTAT2_NVF_INVAL) {</span>
<span class="nc" id="L293">                    return null;</span>
                }
<span class="nc bnc" id="L295" title="All 6 branches missed.">                switch (nv.type) {</span>
                case KSTAT2_NVVT_MAP:
<span class="nc" id="L297">                    return nv.data.map;</span>
                case KSTAT2_NVVT_INT:
<span class="nc" id="L299">                    return nv.data.integerVal;</span>
                case KSTAT2_NVVT_INTS:
<span class="nc" id="L301">                    return nv.data.integers.addr.getLongArray(0, nv.data.integers.len);</span>
                case KSTAT2_NVVT_STR:
<span class="nc" id="L303">                    return nv.data.strings.addr.getString(0);</span>
                case KSTAT2_NVVT_STRS:
<span class="nc" id="L305">                    return nv.data.strings.addr.getStringArray(0, nv.data.strings.len);</span>
                default:
<span class="nc" id="L307">                    return null;</span>
                }
<span class="nc" id="L309">            } catch (Kstat2StatusException e) {</span>
<span class="nc" id="L310">                return null;</span>
            }
        }
    }

    /**
     * Immutable Name/Value pair.
     */
    @FieldOrder({ &quot;name&quot;, &quot;type&quot;, &quot;kind&quot;, &quot;flags&quot;, &quot;data&quot; })
    class Kstat2NV extends Structure {
        public String name; // Name of the pair
        public byte type; // Value type of the pair
        public byte kind; // Kind of the pair
        public short flags; // Flags of the pair
        public UNION data; // Data value

<span class="nc" id="L326">        public static class UNION extends Union {</span>
            public Kstat2Map map;
            public long integerVal;
            public IntegersArr integers;
            public StringsArr strings;

            @FieldOrder({ &quot;addr&quot;, &quot;len&quot; })
<span class="nc" id="L333">            public static class IntegersArr extends Structure {</span>
                public Pointer addr;
                public int len; // length of array
            }

            @FieldOrder({ &quot;addr&quot;, &quot;len&quot; })
<span class="nc" id="L339">            public static class StringsArr extends Structure {</span>
                public Pointer addr;
                public int len; // length of array
            }
        }

        public Kstat2NV() {
<span class="nc" id="L346">            super();</span>
<span class="nc" id="L347">        }</span>

        public Kstat2NV(Pointer p) {
<span class="nc" id="L350">            super(p);</span>
<span class="nc" id="L351">            read();</span>
<span class="nc" id="L352">        }</span>

        @Override
        public void read() {
<span class="nc" id="L356">            super.read();</span>
<span class="nc bnc" id="L357" title="All 5 branches missed.">            switch (type) {</span>
            case KSTAT2_NVVT_MAP:
<span class="nc" id="L359">                data.setType(Kstat2Map.class);</span>
<span class="nc" id="L360">                break;</span>
            case KSTAT2_NVVT_INT:
<span class="nc" id="L362">                data.setType(long.class);</span>
<span class="nc" id="L363">                break;</span>
            case KSTAT2_NVVT_INTS:
<span class="nc" id="L365">                data.setType(IntegersArr.class);</span>
<span class="nc" id="L366">                break;</span>
            case KSTAT2_NVVT_STR:
            case KSTAT2_NVVT_STRS:
<span class="nc" id="L369">                data.setType(StringsArr.class);</span>
<span class="nc" id="L370">                break;</span>
            default:
                break;
            }
<span class="nc" id="L374">            data.read();</span>
<span class="nc" id="L375">        }</span>
    }

    /**
     * Initializes an opaque kstat2 handle that provides access to a specific view
     * of the kernel statistics.
     *
     * @param handle
     *            A pointer to the handle to be initialized.
     * @param matchers
     *            Only kstats that match one or more of the provided matchers will
     *            be available. If a NULL or empty matcher list is provided, all of
     *            the system's kstats will be available, which is equivalent to
     *            calling the kstat2_open() function. Restricting the number of
     *            kstats available will improve performance and reduce the memory
     *            footprint.
     * @return Upon successful completion, returns a int value of
     *         {@link Kstat2#KSTAT2_S_OK}. If an error occurs a value other than
     *         KSTAT2_S_OK is returned.
     */
    int kstat2_open(PointerByReference /* Kstat2Handle */ handle, Kstat2MatcherList matchers);

    /**
     * Synchronises the user's view with that of the kernel. The kernel may at any
     * point add or remove kstats, causing the user's view of the available kstats
     * to become out of date. The kstat2_update() function should be called
     * periodically to resynchronise the two views.
     *
     * @param handle
     *            The handle to be updated.
     * @return Upon successful completion, returns a int value of
     *         {@link Kstat2#KSTAT2_S_OK}. If an error occurs a value other than
     *         KSTAT2_S_OK is returned.
     */
    int kstat2_update(Kstat2Handle handle);

    /**
     * The kstat2_close() function frees all resources that are associated with the
     * handle. It is the caller's responsibility to free any allocated matcher list
     * by calling the kstat2_free_matcher_list() function.
     *
     * @param handle
     *            A reference to the handle to close.
     * @return Upon successful completion, returns a int value of
     *         {@link Kstat2#KSTAT2_S_OK}. If an error occurs a value other than
     *         KSTAT2_S_OK is returned.
     */
    int kstat2_close(PointerByReference /* Kstat2Handle */ handle);

    /**
     * Allocates a new matcher list to allow matchers to be provided to the
     * {@link Kstat2#kstat2_open(PointerByReference, Kstat2MatcherList)} function.
     *
     * @param matchers
     *            Receives a pointer to the allocated matcher list.
     * @return Upon successful completion, returns a int value of
     *         {@link Kstat2#KSTAT2_S_OK}. If an error occurs a value other than
     *         KSTAT2_S_OK is returned.
     */
    int kstat2_alloc_matcher_list(PointerByReference /* Kstat2MatcherList */ matchers);

    /**
     * Frees the resources associated with the matcher list.
     *
     * @param matchers
     *            A pointer to the {@link Kstat2MatcherList} to be freed.
     * @return Upon successful completion, returns a int value of
     *         {@link Kstat2#KSTAT2_S_OK}. If an error occurs a value other than
     *         KSTAT2_S_OK is returned.
     */
    int kstat2_free_matcher_list(PointerByReference /* Kstat2MatcherList */ matchers);

    /**
     * Adds matchers to the provided matcher list. Each call appends the new matcher
     * to the provided matcher list. Matches are on kstat URI, with the following
     * match types supported: {@link Kstat2#KSTAT2_M_STRING} which performs a direct
     * {@code strcmp} with the kstat URI, {@link Kstat2#KSTAT2_M_GLOB} which
     * performs a glob pattern match using {@code gmatch}, and
     * {@link Kstat2#KSTAT2_M_RE} which performs a Perl Compatible Regular
     * Expression (PCRE) match using {@code pcre_exec}.
     *
     * @param type
     *            The type of matcher, from the {@code kstat2_match_type_t}
     *            enumeration.
     * @param match
     *            The string to match.
     * @param matchers
     *            The list to which to append the matcher.
     * @return Upon successful completion, returns a int value of
     *         {@link Kstat2#KSTAT2_S_OK}. If an error occurs a value other than
     *         KSTAT2_S_OK is returned.
     */
    int kstat2_add_matcher(int type, String match, Kstat2MatcherList matchers);

    /**
     * Obtains a reference to a kstat2 map given the URI of the map.
     *
     * @param handle
     *            The handle to obtain the map from.
     * @param uri
     *            The string to match.
     * @param map
     *            Receives a reference to the relevant map.
     * @return Upon successful completion, the function will set the map parameter
     *         to reference the relevant map and {@link Kstat2#KSTAT2_S_OK} will be
     *         returned. If the requested item cannot be found, the map reference
     *         will be set to {@code NULL} and an error will be returned.
     */
    int kstat2_lookup_map(Kstat2Handle handle, String uri, PointerByReference /* Kstat2Map */ map);

    /**
     * Retrieves the name/value (nv) pair identified by the supplied name. The
     * reference returned is managed by the library and must not be passed to
     * free().
     *
     * @param map
     *            The map from which to retrieve the data.
     * @param name
     *            The uri of the data to retrieve.
     * @param nv
     *            Receives a reference to the name/value data.
     * @return Upon successful completion, returns {@link Kstat2#KSTAT2_S_OK}. If
     *         there is an error performing the requested operation, an error code
     *         will be returned.
     */
    int kstat2_map_get(Kstat2Map map, String name, PointerByReference /* Kstat2NV */ nv);

    /**
     * Gives a descriptive error message for the supplied status value.
     *
     * @param status
     *            A value in the {@code kstat2_status} enumeration.
     * @return A descriptive string for the supplied status code.
     */
    String kstat2_status_string(int status);
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>